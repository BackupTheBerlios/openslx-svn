#!/bin/ash
# Copyright (c) 2008 - OpenSLX GmbH
#
# This program is free software distributed under the GPL version 2.
# See http://openslx.org/COPYING
#
# If you have any feedback please consult http://openslx.org/feedback and
# send your feedback to feedback@openslx.org
#
# General information about OpenSLX can be found at http://openslx.org
#
# Main script for cd-boot demo initial ramfs - preloading environment for
# for running OpenSLX linux stateless clients version 4 for testing

#############################################################################
# helper function: compute prefix bit number from netmask
# fixme: replace with ipcalc -p $ip $netmask
nm2pref () {
set $(IFS="."; echo $1)
local n=0
local i
  for i in $1 $2 $3 $4 ; do
    case $i in
        0) break ;;
      128) n=$(($n + 1)) ; break ;;
      192) n=$(($n + 2)) ; break ;;
      224) n=$(($n + 3)) ; break ;;
      240) n=$(($n + 4)) ; break ;;
      252) n=$(($n + 6)) ; break ;;
      254) n=$(($n + 7)) ; break ;;
      255) n=$(($n + 8)) ; continue ;;
    esac
  done
echo $n
}

#############################################################################
# device files get their own filesystem (to be move mounted later)
devdir="/dev"
mount -n -t tmpfs -o 'size=25%,mode=0755' initramfsdevs ${devdir}
NWMODULES="forcedeth e1000 e100 tg3 3c59x via-rhine r8169 pcnet32 b44 8139too"
DEBUGLEVEL=0

# create basic device files an directories in dev (for most hardware related
# devices mdev should handle that)
for i in "/dev/mem c 1 1" "/dev/null c 1 3" "/dev/zero c 1 5" \
         "/dev/urandom c 1 9" "/dev/kmsg c 1 11" "/dev/tty0 c 4 0" \
         "/dev/tty1 c 4 1" "/dev/tty2 c 4 2" "/dev/tty3 c 4 3" \
         "/dev/tty4 c 4 4" "/dev/tty5 c 4 5" "/dev/tty6 c 4 6" \
         "/dev/tty7 c 4 7" "/dev/tty8 c 4 8" "/dev/tty9 c 4 9" \
         "/dev/tty10 c 4 10" "/dev/tty c 5 0" "/dev/console c 5 1" \
         "/dev/ptmx c 5 2" "/dev/psaux c 10 1" "/dev/agpgart c 10 175" \
         "/dev/fb0 c 29 0" "/dev/bootsplash p" "/dev/xconsole p"; do
  mknod $i
done
mkdir -p ${devdir}/pts ${devdir}/shm ${devdir}/.udevdb ${devdir}/.udev

# source functions file common for all distros, messages contains all error
# and info output (for some reason the error output is not produced properly
# - crash)

# initramfs-setup configuration (common settings for all clients using a
# certain InitRamFS generated by slxmkramfs/mkdxsinitrd)
[ -f /etc/initramfs-setup ] && . /etc/initramfs-setup 2>/dev/null

export PATH=/bin:/sbin:/usr/bin/:/usr/sbin

# set a default LAN interface, might be modified for WLAN or on machines with
# more than one ethernet card built in
nwif="eth0"

# mount the important standard directories
[ ! -f /proc/cpuinfo ] && mount -n -t proc proc /proc
[ ! -d /sys/class ] && mount -n -t sysfs sysfs /sys

# keep quiet
#echo "0 0 0 0" >/proc/sys/kernel/printk

# fixme: shut down if script fails
trap "exec (sleep 30; echo o>/proc/sysrq-trigger)" \
  SIGHUP SIGINT SIGPIPE SIGTERM

# if no kernel version is set, try to get it directly from /proc
if [ -z $KERNEL ] ; then
  KERNEL=$(cat /proc/version)
  KERNEL=${KERNEL#*version }
  KERNEL=${KERNEL% (*) (*}
fi

# load network adaptor modules
for mod in ${NWMODULES}; do
  modprobe ${MODPRV} $mod || echo "module $mod did not load for some reason"
  usleep 10000 
done

# read kernel commandline
read KCMDLINE < /proc/cmdline
# read the system wide machine-setup and then the kernel commandline
for opts in ${KCMDLINE} ; do
  case ${opts} in
    debug)
      DEBUGLEVEL=1;;
    # ... or a specified debug level (will be passed to next stage)
    debug=*)
      DEBUGLEVEL=${opts#debug=};;
  esac
done
# at this point a timer should be started to ensure an automated reboot
# or halt of the machine if SLX init does not succeed (e.g. missing kernel
# module for the network adaptor)
if [ "${DEBUGLEVEL}" -gt 0 ] ; then
  cat<<EOF > /bin/watchdog
#!/bin/ash
echo \$$ > /tmp/watchdogpid
[ ! -f /proc/version ] && mount -n -t proc proc /proc
sleep 120 2> /dev/null
echo "o" > /proc/sysrq-trigger
EOF
  chmod u+x /bin/watchdog
  watchdog &
fi

if [ -n "${essid}" ] ; then
  # WLAN setup will most probably change the network interface name stored in
  # nwif (to wlan0 or something like that)
  :
else
  # check here for the active ethernet link
  ip link show dev eth1 >/dev/null 2>&1 && echo "more than one nw if found"
fi

# set up loopback networking and power up ethernet
ip link set dev lo up
ip addr add 127.0.0.1/8 dev lo
ip link set dev $nwif up || echo "I did not find any usable network adaptor."

# start udhcpc, if no lease could be optained, start debug shell
mkdir -p /usr/share/udhcpc
echo -e "#!/bin/ash\nunset infomsg HOME IFS mask lease interface DEBUGLEVEL \
BOOT_IMAGE\nset >/tmp/ipstuff" >/usr/share/udhcpc/default.script
chmod u+x /usr/share/udhcpc/default.script
modprobe -q af_packet
[ -n $vci ] && vci="-V $vci"
udhcpc -n -q $vci -s /usr/share/udhcpc/default.script -i $nwif 2>/dev/null
if grep "ip=" /tmp/ipstuff >/dev/null 2>&1 ; then
  . /tmp/ipstuff
  for i in $dns ; do
    echo "nameserver $i" >> /etc/resolv.conf
  done
else
  echo "Did not get any proper IP configuration"; /bin/ash
fi
ip addr add $ip/$(nm2pref $subnet) dev $nwif
ip route add default via $router  

# at this point a little selection script could be downloaded, which lets the
# user choose what kind of SLX client he wants to get

# get kernel and initramfs, if something fails start debug shell
echo "Fetching selected kernel and initial ramfs from the net ..."
( wget -q -c -O /tmp/kernel \
  ftp://openslx:OpenS1X@archive.ruf.uni-freiburg.de/kernel 2>/dev/null && \
wget -q -c -O /tmp/iramfs \
  ftp://openslx:OpenS1X@archive.ruf.uni-freiburg.de/iramfs 2>/dev/null ) || \
  /bin/ash

# start a debug shell if needed, else set quiet kernel parameter
if [ "${DEBUGLEVEL}" -gt 0 ] ; then
  /bin/ash
else
  quiet=quiet
  echo -e "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"
fi

# start the new kernel with initialramfs and cmdline
echo "Booting OpenSLX client ..."
kexec -l /tmp/kernel --initrd=/tmp/iramfs --append="ip=$ip:$siaddr:$router:$subnet\
  file=ftp://132.230.4.4/default.tgz debug=${DEBUGLEVEL} $quiet"
kexec -e

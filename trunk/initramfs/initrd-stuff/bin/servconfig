# Copyright (c) 2003 - 2006 - RZ Uni Freiburg
# Copyright (c) 2006, 2007 - OpenSLX GmbH
#
# This program is free software distributed under the GPL version 2.
# See http://openslx.org/COPYING
#
# If you have any feedback please consult http://openslx.org/feedback and
# send your feedback to feedback@openslx.org
#
# General information about OpenSLX can be found under http://openslx.org
#
# universal (distro independent) configuration script for OpenSLX linux
# diskless clients (executed in stage3 within initial ramfs). The file-
# system setup is completed when servconfig starts

#############################################################################
# check for configuration files to source

# functions common for all distros, messages contains all error and
# info output
. /etc/messages
. /etc/functions
# load distro specific configuration variables and functions. distro
# specific functions may overwrite functions defined in /etc/functions
. /etc/sysconfig/config
. /etc/distro-functions
. /etc/sysconfig/slxsystem.conf
# get location of logfile definition
. /mnt/etc/${D_SYSCONFDIR}/logfile

# script run timer
[ $DEBUGLEVEL -eq 8 ] && echo "** SW setup started at $(sysup)"

# heavy debugging output in level 3 and below 8 ...
[ $DEBUGLEVEL -gt 3 -a $DEBUGLEVEL -lt 8 -o $DEBUGLEVEL -eq 12 ] && \
  set -x

#############################################################################
# copy distro specific scripts, programs, libraries and configs
cp -a /etc/sysconfig/files/* /mnt 2>/dev/null &
# boot.local file (different for several distros)
[ -f "/etc/boot.local" -a -n "${D_BOOTLOCAL}" ] && {
  echo "# added by $0 (initramfs from $date)" >> /mnt/etc/${D_BOOTLOCAL}
  cat /etc/boot.local >> /mnt/etc/${D_BOOTLOCAL}
}

#############################################################################
# read and unify configuration options - default configuration file, from
# dhcp, ldap ...
# wait for the appearance of configuration from several sources
cfgcomplete
. /etc/machine-setup
[ $DEBUGLEVEL -eq 8 ] && echo "** Config info is complete at $(sysup)"

# copy additional configuration and var files and directories
# admins can place there files in /var/lib/openslx/config/...
# to be packed during stage2 into (/srv/dxs)/tftpboot/client-config...)
# ... in the near future ...
cp -a /rootfs/* /mnt 2>/dev/null

# set greeting and add information on booted system
len=$(expr length ${SLXVERSION}${SYSTEM_NAME})
if [ $len -le 28 ] ; then
  vdstr="Stateless Workstation (V${SLXVERSION}/${SYSTEM_NAME})"
  smax=28
else
  vdstr="V${SLXVERSION}/${SYSTEM_NAME}"
  smax=52
fi
while [ $len -le $smax ] ; do
  vdstr="$vdstr "
  len=$(($len + 1))
done
len=$(expr length $host_name)
while [ $len -le 30 ] ; do
  space="$space "
  len=$(($len + 1))
done
echo "
   WELCOME TO                 $space       \n (\l)
           _____  ______  ______ __    __    _______ __     __    __
          /  _   |   _   |   ___|  |  |  |  |   ____|  |   |  |  |  |
         |  | |  |  |_|  |  |_  |   |    |  |  |___ |  |        /  /
         |  | |  |   ___/|   _|      |   |   ____   |  |     |    |
         |  |_|  |  |    |  |___|  |  |  |   ____|  |  |___ /  /
           _____/|__|    |______|__|  |__|  |_______|______|__|  |__|

   $vdstr (c) <OpenSLX.ORG>
">/mnt/etc/issue

#############################################################################
# set localization and add entries to initialize keytable and consolefont to
# boot.slx
DEFKEYTABLE="de-latin1-nodeadkeys"
if [ -z "$country" ] ; then
  error "$scfg_country" nonfatal
  country="${D_DEFAULTCOUNTRY}"
fi
localization "${country}"
if [ -z "${KEYTABLE}" ] ; then
  error "$hcfg_keyb" nonfatal
  KEYTABLE=${DEFKEYTABLE}
fi
echo -e "\t# entries added by $0: $date" >> /mnt/etc/${D_INITDIR}/boot.slx
[ -n "${KEYTABLE}" ] && keytable
[ -n "${CONSOLE_FONT}" ] && consolefont

#############################################################################
# vmware stuff first part: two scenarios
# * VM images in /usr/share/vmware - then simply link
# * VM images via additional mount (mount source NFS, NBD, ...)
if [ "x$vmware" != "x" ] && [ "x$vmware" != "xno" ] ; then
  # map slxgrp to pool, so it's better to understand
  pool=${slxgrp}
  # if we dont have slxgrp defined
  [ -z "$pool" ] && pool="default"

  # get source of vmware image server (get type, server and path)
  if strinstr "/" "$vmware" ; then
    vmimgprot=$(uri_token $vmware prot)
    vmimgserv=$(uri_token $vmware server)
    vmimgpath="$(uri_token $vmware path)"
  fi
  if [ -n "${vmimgserv}" ] ; then
    testmkd /mnt/var/lib/vmware
    case "${vmimgprot}" in
      *nbd)
      ;;
      lbdev)
        # we expect the stuff on toplevel directory, filesystem type should be
        # autodetected here ... (vmimgserv is blockdev here)
        vmbdev=/dev/${vmimgserv}
        waitfor ${vmbdev} 20000
        echo -e "ext2\nreiserfs\nvfat\nxfs" >/etc/filesystems 
        mount -o ro ${vmbdev} /mnt/var/lib/vmware || error "$scfg_evmlm" nonfatal
      ;;
      *)
        # we expect nfs mounts here ...
        for proto in tcp udp fail; do
          [ $proto = "fail" ] && { error "$scfg_nfs" nonfatal;
            noimg=yes; break;}
          mount -n -t nfs -o ro,nolock,$proto ${vmimgserv}:${vmimgpath} \
            /mnt/var/lib/vmware && break
        done
      ;;
    esac
  fi
fi

#############################################################################
# setup passwd and shadow for local system users like root, bin, daemon and
# nobody if no user/admin provided passwd exists ...
# the root password provided by machine-setup is used only if no passwd file
# is provided (default case)
if [ ! -f /rootfs/etc/passwd ] ; then
  basepasswd
fi

#############################################################################
# dns and ip configuration
# hostname of the machine
echo "$host_name" >/proc/sys/kernel/hostname
echo -e "# /etc/hosts - file generated by\n#\t$0:\n#\t$date\
\n#\n# IP-Address  Full-Qualified-Hostname  Short-Hostname\n#\n\
127.0.0.1\tlocalhost\n::1\t\tlocalhost ipv6-localhost ipv6-loopback\n\
fe00::0\t\tipv6-localnet\nff00::0\t\tipv6-mcastprefix\nff02::1\
\t\tipv6-allnodes\nff02::2\t\tipv6-allrouters\nff02::3\t\t\
ipv6-allhosts\n" >/mnt/etc/hosts
if [ -n  "$domain_name" ]; then
  echo -en "$clientip\t" >>/mnt/etc/hosts
  for name in $domain_name; do
    echo -en "$host_name.$name " >>/mnt/etc/hosts
  done
  echo -e "$host_name" >>/mnt/etc/hosts
else
  echo -e "$clientip\t$host_name" >>/mnt/etc/hosts
fi
# set up domainname and resolving
rm -rf /mnt/etc/resolv.conf
test -n "$domain_name" && \
  echo -e "# /etc/resolv.conf - file generated by\n#\t$0:\n\
#\t$date\n#options timeout:1 attempts:1 rotate\n\
search "$domain_name >/mnt/etc/resolv.conf
test -n "$domain_name_servers" && {
  for name in $domain_name_servers; do
    echo nameserver $name >>/mnt/etc/resolv.conf;
  done; }

#############################################################################
# initial boot scripts
# delete and create runlevel links for initial booting (SuSE, Debian, Ubuntu,
# Fedora, ...)
# splashy stuff
if [ ${nosplash} = 0 ]; then
  D_INITSCRIPTS="${D_INITSCRIPTS} splashy.stop"
  d_mkrlscript init splashy.stop "Stopping Splashy ..."
  echo -e "\t/var/lib/openslx/bin/splashy_update exit 2>/dev/null
    \tkillall -9 splashy\n\trm -f /var/lib/openslx/bin/splashy_update" \
    >>/mnt/etc/${D_INITDIR}/splashy.stop
  d_mkrlscript close splashy.stop ""
fi

initial_boot

#############################################################################
# run distro specific configuration function
config_distro

#############################################################################
# boot.local (fixme: deprecated)
if [ -n "$bootlocal_script" ]; then
  echo -e "# Option is deprecated and will be removed soon. Please put the \
file to the ConfTGZ (rootfs/etc/${D_INITDIR}/boot.local)" >> \
  /mnt/etc/${D_INITDIR}/boot.local
fi

#############################################################################
# basic (non network) services

# at daemon - calling distro specific function config_atd
config_atd

# configuration of cron services - calling distro specific function
# config_cron (runlevel links, directories, ...)
config_cron
[ "x$crontab_entries" != "x" ] && \
    echo -e "$crontab_entries" >> /mnt/etc/crontab

# setup system log services - distro dependent function config_syslog
config_syslog

# acpi and powersave - distro dependent function config_acpi, these daemons
# might require dbus
config_acpi

# configure dbus - distro dependent function config_dreshal - handle
# all stuff regarding dependent services like dbus, resmgr, hal ...
# (check for runlevel scripts, passwd entries, directories ...)
config_dreshal

# configure automounter
if [ "x$automnt" != "xno" ] ; then
  # check if there is some user provided configuration (only auto.master is
  # important) and skip automatic setup
  if [ ! -f /rootfs/etc/auto.master ] ; then
    if [ -d /mnt/misc ] ; then
      echo -e "# /etc/auto.master - file generated by $0:\n\
/misc\t/etc/auto.misc" >/mnt/etc/auto.master
      echo -e "# /etc/auto.misc - file generated by $0:" >/mnt/etc/auto.misc
    else
      echo -e "# /etc/auto.master - file generated by $0:\n\
/misc\t#/etc/auto.misc" >/mnt/etc/auto.master
      echo -e "# /etc/auto.misc - file generated by $0:\nautomount for \
removable devices is mostly deprecated, so /misc is not\nactivated in \
auto.master." >/mnt/etc/auto.misc
    fi
    if [ -n "${automnt_src}" ] ; then
      # local directory and home directory server from machine-setup
      [ -z "${automnt_dir}" ] && automnt_dir="/home"
      # remove leading and trailing slash
      automnt_dir=${automnt_dir#/}
      automnt_dir=${automnt_dir%/}
      test -d /${automnt_dir} || error "$scfg_erradir" nonfatal
      strinstr "/" ${automnt_dir} && error "$scfg_erratpld" nonfatal
      amserv=$(uri_token $automnt_src server)
      ampath=$(uri_token $automnt_src path)
      echo -e "/${automnt_dir}\t/etc/auto.${automnt_dir}\n" \
        >> /mnt/etc/auto.master
      echo -e "# /etc/auto.${automnt_dir} created by $0:\n" \
        > /mnt/etc/auto.${automnt_dir}
      echo -e "*\t-rsize=32768,wsize=32768,rw\t${amserv}:${ampath}/&" \
        >> /mnt/etc/auto.${automnt_dir}
      # no tempfs needed if automounter operates on /home
      [ "${automnt_dir}" = "home" ] && umount -t tmpfs /mnt/home 2>/dev/null
      # portmapper is needed for remote NFS sources and local nfs directories
      testmkd /mnt/var/lib/nfs/state
      config_portmap
    fi
  fi
  config_automount
fi

# configure print services / start requested printer daemon
config_printer

# configure bluetooth services
config_bt

#############################################################################
# network(ed) services

# network time service (ntp) configuration file
if [ -n "$ntp_servers" -a ! -f /rootfs/etc/ntp.conf ]; then
  echo -e "# /etc/ntp.conf - file generated by $0: \
$date\n" >/mnt/etc/ntp.conf
  for name in $ntp_servers; do
    echo server $name >>/mnt/etc/ntp.conf
  done
fi
# copy timezone file defined with language settings
[ -z "$TZ" ] && TZ="$timezone"
ln -snf /usr/share/zoneinfo/${TZ} /mnt/etc/localtime || \
  error "$scfg_ntptz" nonfatal
config_ntp

# secure shell server - at the moment all clients share one "secret"
# key or the key has to be regenerated on every bootup or fetched on
# every bootup from somewhere
config_sshd

# simple network management protocol agent
config_snmp

# setup afs client stuff
config_afs

# setup nfsv4/krb stuff
config_nfsv4

# configure samba service
config_samba

#############################################################################
# NIS
# setup nis configuration if needed
if [ "x$nis_domain" != "x" ] && [ "x$nis_servers" != "x" ] ; then
  echo $nis_domain >/mnt/etc/defaultdomain
  echo -e "# /etc/yp.conf - file generated by $0:\n#\t\
$date\n\nypserver "$nis_servers >/mnt/etc/yp.conf
  # should be last in passwd file
  strinfile "+:::" /mnt/etc/passwd || echo "+::::::" >>/mnt/etc/passwd
  config_nis
fi

#############################################################################
# name service caching daemon if networked user database
config_nscd

#############################################################################
# vmware stuff second part: setting up the environment

# create needed directories and files
if [ "x$vmware" != "x" ] && [ "x$vmware" != "xno" ] ; then
  for i in /etc/vmware/vmnet1/dhcpd /etc/vmware/vmnet8/nat \
           /etc/vmware/vmnet8/dhcpd /var/run/vmware /etc/vmware/loopimg \
           /etc/vmware/fd-loop /var/X11R6/bin /etc/X11/sessions; do
    testmkd /mnt/$i
  done
  # create needed devices (not created automatically via module load)
  for i in "/dev/vmnet0 c 119 0" "/dev/vmnet1 c 119 1" \
           "/dev/vmnet8 c 119 8" "/dev/vmmon c 10 165"; do
    mknod $i
  done
  # create the vmware startup configuration file /etc/vmware/locations
  # fixme --> ToDo
  # echo -e "answer VNET_8_NAT yes\nanswer VNET_8_HOSTONLY_HOSTADDR \n\
#192.168.100.1\nanswer VNET_8_HOSTONLY_NETMASK 255.255.255.0\n\
#file /etc/vmware/vmnet8/dhcpd/dhcpd.conf\n\
# remove_file /etc/vmware/not_configured" >/mnt/etc/vmware/locations

  chmod 0700 /dev/vmnet*
  chmod 1777 /mnt/etc/vmware/fd-loop
  # loop file for exchanging information between linux and vmware guest
  if modprobe ${MODPRV} loop; then
    mdev -s
  else
    : #|| error "" nonfatal
  fi
  # mount a clean tempfs (bug in UnionFS prevents loopmount to work)
  strinfile "unionfs" /proc/mounts && \
    mount -n -o size=1500k -t tmpfs vm-loopimg /mnt/etc/vmware/loopimg
  # create an empty floppy image of 1.4MByte size
  dd if=/dev/zero of=/mnt/etc/vmware/loopimg/fd.img \
    count=2880 bs=512 2>/dev/null
  chmod 0777 /mnt/etc/vmware/loopimg/fd.img
  # use dos formatter from rootfs (later stage4)
  LD_LIBRARY_PATH=/mnt/lib /mnt/sbin/mkfs.msdos \
    /mnt/etc/vmware/loopimg/fd.img >/dev/null 2>&1 #|| error
  mount -n -t msdos -o loop,umask=000 /mnt/etc/vmware/loopimg/fd.img \
    /mnt/etc/vmware/fd-loop
  echo -e "usbfs\t\t/proc/bus/usb\tusbfs\t\tauto\t\t 0 0" >> /mnt/etc/fstab
  # needed for VMware 5.5.3 and versions below
  echo -e "\tmount -t usbfs usbfs /proc/bus/usb 2>/dev/null" \
    >>/mnt/etc/${D_INITDIR}/boot.slx
  config_vmware
  chmod 1777 /mnt/var/run/vmware
  # define a variable where gdm/kdm should look for additional sessions
  # do we really need it?
  # export vmsessions=/var/lib/vmware/vmsessions

  # directory of templates and xdialog files
  vmdir=/mnt/var/lib/vmware
  
  if cp ${vmdir}/templates/xdialog.sh /mnt/var/X11R6/bin 2>/dev/null; then
    # create default.desktop for kdm
    echo -e "[Desktop Entry]\nEncoding=UTF8\nName=Default\nName[de]=Standard"\
      >/mnt/etc/X11/sessions/default.desktop

    #I dont like this part, but there is no simple workaround. We need to
    #create xdialog.sh on every box :(
    echo "Exec=/var/X11R6/bin/xdialog.sh" \
      >>/mnt/etc/X11/sessions/default.desktop
    echo "Type=Application" >>/mnt/etc/X11/sessions/default.desktop

    # /usr/share/xsessions/* files for the menu
    for i in /mnt/usr/share/xsessions/*.desktop; do
      # execute
      echo "\"$(grep '^Exec=' ${i}|sed 's/^Exec=//')\" \\" \
        >>/mnt/var/X11R6/bin/xdialog.sh
      # short description
      echo "\"$(grep '^Name=' ${i}|sed 's/^Name=//')\" \\" \
        >>/mnt/var/X11R6/bin/xdialog.sh
      # long description
      echo "\"$(grep '^Comment=' ${i}|sed 's/^Comment=//')\" \\" \
        >>/mnt/var/X11R6/bin/xdialog.sh
    done
    # all virtual machine clients
    cat ${vmdir}/xdialog-files/${pool}/*.xdialog \
      >>/mnt/var/X11R6/bin/xdialog.sh
    # closing bracket as last line ends with '\'
    echo ")" >>/mnt/var/X11R6/bin/xdialog.sh
    chmod 755 /mnt/var/X11R6/bin/xdialog.sh

    # copy xdm files, so we could choose them before we log in
    for i in ${vmdir}/xdmsessions/${pool}/*.desktop;do
      cp ${i} /mnt/etc/X11/sessions/
    done
  else
    error "$scfg_vmchs" nonfatal
  fi
  # we configured vmware, so we can delete the not_configured file
  rm /mnt/etc/vmware/not_configured 2>/dev/null

  # copy dhcpd.conf and nat for vmnet8 (nat)
  # fixme: It should be possible to start just one vmware dhcp which should
  # listen to both interfaces vmnet1 and vmnet8 ...
  cp /mnt/var/lib/vmware/templates/dhcpd.conf \
    /mnt/etc/vmware/vmnet8/dhcpd 2>/dev/null
  cp /mnt/var/lib/vmware/templates/nat.conf \
    /mnt/etc/vmware/vmnet8/nat 2>/dev/null
fi

#############################################################################
# theming
testmkd /mnt/var/lib/openslx/themes/displaymanager
testmkd /mnt/var/lib/openslx/bin
[ -d /usr/share/themes/displaymanager ] && \
  cp -a /usr/share/themes/displaymanager /mnt/var/lib/openslx/themes
[ -d /etc/splashy -a ${nosplash} = 0 ] && (cp -a /bin/splashy_update \
    /mnt/var/lib/openslx/bin)

#############################################################################
# preparation of /tmp directory (partition 44, nfs scratch, ramdisk). there
# might be the chance that we have a disk partition available, so wait for
# completion of detection, setup process
[ $DEBUGLEVEL -eq 8 ] && echo "** Waiting for /tmp completion at $(sysup)"
waitfor /tmp/tmpready 40000
[ $DEBUGLEVEL -eq 8 ] && echo "** Setup of /tmp completed at $(sysup)"
# create some directories and correct permissions
tmpisdisk=$(sed -n '/\/tmp/p' /tmp/fstab 2>/dev/null)
# if there is no local disk partition for /tmp then try to mount a rw
# scratch space (if defined in $scratch) and prepared on server
if [ -n "$scratch" -a -z "$tmpisdisk" ] ; then
  scrproto=$(uri_token $FILESRC prot)
  scrpath=$(uri_token $FILESRC path)
  testmkd /tmp/scratch
  # exports have to be per client!!
  case "$scrproto" in
    nbd)
      :
    ;;
    *)
    tmpserv=$(uri_token $scratch server)
    tmppath=$(uri_token $scratch path)
    # hanging mount processes might stop further setup - timeout
    # should be configured ... it is possible to mount "nolock" only
    mount -t nfs -o rw,tcp,nolock,intr,nodev,soft,timeo=2,nosuid \
      ${tmpserv}:${tmppath} /tmp/scratch >/dev/null 2>&1 && {
      testmkd /tmp/scratch/${clientip}
      umount /tmp/scratch
      # no need for tempfs there ...
      umount /mnt/tmp >/dev/null 2>&1
      mount -t nfs -o rw,tcp,nolock,intr,nodev,soft,timeo=2,nosuid \
        ${tmpserv}:${tmppath}/${clientip} /mnt/tmp >/dev/null 2>&1; }
    ;;
  esac
fi

#############################################################################
# X11/GUI stuff
if [ "x$start_x" != "xno" ] ; then
  # creating directories commonly needed for X11 in all distros
  # rest should be done via config_x11 function (distro specific)
  for i in /var/lib/xkb/compiled \
           /etc/X11/xdm \
           /etc/X11/sessions \
           /var/X11R6/bin \
           /var/run/xdmctl \
           /tmp/.ICE-unix \
           /tmp/.X11-unix ; do testmkd /mnt/$i; done
  chmod 1777 /mnt/tmp/.ICE-unix /mnt/tmp/.X11-unix
  chown 0:0 /mnt/tmp/.ICE-unix /mnt/tmp/.X11-unix
  echo "# file emtied by $0 during initramfs" > /mnt/etc/X11/xdm/Xservers
  # define additional sessions offered to the user (via dhcp/ldap config)
  # descsession -> deprecated by new vmware integration concept
  # write available X display manager to /etc/X11/xdm/Xaccess
  [ -n "$x_display_manager" ] && \
  echo -e "# /etc/X11/xdm/Xaccess - file generated by $0: \
$date\n*\n%hostlist\t$x_display_manager\n*\t\tCHOOSER %hostlist"\
    >/mnt/etc/X11/xdm/Xaccess

  # define type of X session
  dsx="no"
  case "$start_x" in
    yes|YES|direct|DIRECT|query|QUERY)
      # direct connection onto the own displaymanager, which
      # should be enabled then
      [ "x$start_xdmcp" = "xno" ] && $start_xdmcp="yes"
      init=""
      dsx="yes"
      xdmcp="false"
      echo -e "# /etc/X11/Xservers - file generated by \
$0: $date\n:0 local X :0 vt07\n" >/mnt/etc/X11/xdm/Xservers
    ;;
    broadcast|BROADCAST)
      # the client will XDMCP broadcast and choose first available
      # X11 server
      [ "x$start_xdmcp" = "xgdm" ] || \
        init="7:5:respawn:${D_XORGBIN} vt7 -quiet -broadcast"
    ;;
    indirect|INDIRECT)
      # the client will try to XDMCP connect list of X11 servers
      if [ "x$start_xdmcp" = "xgdm" ] ; then
        init=""
      else
        init="7:5:respawn:${D_XORGBIN} vt7 -quiet -indirect $host_name"
      fi
      [ "x$start_xdmcp" = "xno" ] && start_xdmcp="yes"
      xdmcp="true"
    ;;
    *)
      # no display manager needed in kiosk mode
      # in this mode you have to provide the type of X session to start
      [ x$start_xdmcp != "x" ] || start_xdmcp="no";
      init="7:5:respawn:/var/X11R6/bin/kiosk /dev/tty7"
      # nobody can halt pc 
      echo 'nobody ALL=NOPASSWD:/sbin/halt, /sbin/shutdown' >>/mnt/etc/sudoers
      echo -e "#!/bin/sh\n# /var/X11R6/bin/kiosk - file generated by $0: $date
      while ps aux|grep -i kiosk|grep -v \"grep\" &>/dev/null; do
        test -f /var/run/kiosk || break; sleep 3;
      done
      touch /var/run/kiosk
      for((i=0;\$i<=120;i=\$((\$i+1)))); do
        [ -e /var/run/resmgr.pid ] && break
        [ \$i = 120 ] && exit 1
        sleep 1
      done
      resmgr login nobody tty8 \\
      && resmgr grant nobody desktop \\
      && chown -R nobody:nogroup /var/lib/nobody \\
      && (su -c '(sleep 10; amixer -q sset Master 28 unmute; \\
        amixer -q sset PCM 28 unmute) &
        xinit /var/X11R6/bin/startgui $start_x \\
        -- vt7 -quiet' -l nobody &>/dev/null)
      rm /var/run/kiosk
      resmgr revoke nobody
      resmgr logout tty7
      killall X" >/mnt/var/X11R6/bin/kiosk
      # early start of kiosk session
      echo -e "\t# kiosk start added by $0\n\t\
/var/X11R6/bin/kiosk &>/dev/null &" >>/mnt/etc/${D_INITDIR}/boot.slx
      cp /etc/startgui /mnt/var/X11R6/bin
      chmod a+x /mnt/var/X11R6/bin/kiosk /mnt/var/X11R6/bin/startgui
      rm /mnt/var/run/kiosk 2>/dev/null
    ;;
  esac
  echo -e "# entry made by $0 $date\n$init" >> /mnt/etc/inittab
  # most probably not needed any longer
  if [ -n ${D_XORGBIN} ] ; then
    testmkd /mnt/var/X11R6/bin
    ln -sf ${D_XORGBIN} /mnt/var/X11R6/bin/X
  fi
fi

# setup requested display manager
if [ "x$start_xdmcp" != "xno" ] ; then
  testmkd /mnt/var/lib/xdm/authdir/authfiles
  testmkd /mnt/var/run/xdmctl
  if [ "$start_xdmcp" = "yes" ] ; then
    start_xdmcp=kdm
  fi
  # just ensure lowercase
  start_xdmcp=$(echo $start_xdmcp|sed -e "y/'GKWXDM'/'gkwxdm'/")
  case "$start_xdmcp" in
    wdm)
      # anywhere in use!?
    ;;
    kdm)
      # config is most probably not common in all distros?
      # distro specific function config_kdm
      config_kdm
    ;;
    gdm)
      # config is most probably not common in all distros?
      # distro specific function config_gdm
      config_gdm
    ;;
    *)
      # setup xdm (should be the same over the several distros)
      echo -e "# /etc/X11/xdm/xdm-config - file generated by\n\
#\t$0: $date\n\nDisplayManager.errorLogFile:\t/var/log/xdm.errors\n\
DisplayManager.pidFile:\t\t/var/run/xdm.pid\n\
DisplayManager.authDir:\t\t/var/lib/xdm\n\
DisplayManager.keyFile:\t\t/etc/X11/xdm/xdm-keys\n\
DisplayManager.servers:\t\t/etc/X11/xdm/Xservers\n\
DisplayManager.accessFile:\t/etc/X11/xdm/Xaccess\n\
DisplayManager.willing:\t\tsu nobody -c /etc/X11/xdm/Xwilling\n\
DisplayManager.*.authName:\tMIT-MAGIC-COOKIE-1\n\
DisplayManager.*.authComplain:\tfalse\n\
DisplayManager.*.setup:\t\t/etc/X11/xdm/Xsetup\n\
DisplayManager.*.chooser:\t/etc/X11/xdm/RunChooser\n\
DisplayManager.*.startup:\t/etc/X11/xdm/Xstartup\n\
DisplayManager.*.session:\t/etc/X11/xdm/Xsession\n\
DisplayManager.*.reset:\t\t/etc/X11/xdm/Xreset" \
         >/mnt/etc/X11/xdm/xdm-config
      [ "$xdmcp" = "false" ] && echo -e \
      "DisplayManager.requestPort:\t0\n" >>/mnt/etc/X11/xdm/xdm-config
      # distro specific function config_xdm (at least for runlevel links)
      config_xdm
    ;;
  esac
fi

# script run timer
[ $DEBUGLEVEL -eq 8 ] && echo "** SW setup finished at $(sysup)"

# servconfig finished successfully
echo "servconfig finished at $(sysup)" > /tmp/svcfg

#! /usr/bin/perl
# -----------------------------------------------------------------------------
# Copyright (c) 2006, 2007 - OpenSLX GmbH
#
# This program is free software distributed under the GPL version 2.
# See http://openslx.org/COPYING
#
# If you have any feedback please consult http://openslx.org/feedback and
# send your suggestions, praise, or complaints to feedback@openslx.org
#
# General information about OpenSLX can be found at http://openslx.org/
# -----------------------------------------------------------------------------
# slxconfig-demuxer
#	- OpenSLX configuration demultiplexer
# -----------------------------------------------------------------------------
use strict;

my $abstract = q[
slxconfig-demuxer
    This script will read information about all systems, clients and
    groups from the OpenSLX configuration database, mix & match the individual
    configurational attributes and then demultiplex the resulting information
    to a set of configuration files. These files are used by any OpenSLX-client
    during boot to find out which systems to offer for booting.

    The resulting files will be put into the OpenSLX-tftpboot-path (you can use
    the option --tftpboot-path to override the default taken from the OpenSLX
    default settings).

    Please use the --man option in order to read the full manual.
];

use Fcntl qw(:DEFAULT :flock);
use File::Basename;
use Getopt::Long qw(:config pass_through);
use Pod::Usage;

# add the lib-folder and the folder this script lives in to perl's search
# path for modules:
use FindBin;
use lib "$FindBin::RealBin/../lib";
use lib "$FindBin::RealBin";
	# development path to config-db stuff

use OpenSLX::Basics;
use OpenSLX::ConfigDB qw(:support);
use OpenSLX::Utils;

my $pxeDefaultTemplate =
q[NOESCAPE 0
PROMPT 0
TIMEOUT 10
DEFAULT menu.c32
IMPLICIT 1
ALLOWOPTIONS 1
MENU TITLE Was mÃ¶chten Sie tun (Auswahl mittels Cursortasten)?
MENU MASTER PASSWD secret
];

my (
	$dhcpType,
		# type of DHCP export format
	$dryRun,
		# dryRun won't touch any file
	$systemConfCount,
		# number of system configurations written
	$clientSystemConfCount,
		# number of (system-specific) client configurations written
	$helpReq,
	$manReq,
	$versionReq,
);

GetOptions(
	'dhcp-export-type=s' => \$dhcpType,
	'dry-run' => \$dryRun,
	'help|?' => \$helpReq,
	'man' => \$manReq,
	'version' => \$versionReq,
) or pod2usage(2);
pod2usage(-msg => $abstract, -verbose => 0, -exitval => 1) if $helpReq;
if ($manReq) {
	$ENV{LANG} = 'en_EN';
		# avoid dubious problem with perldoc in combination with UTF-8 that
		# leads to strange dashes and single-quotes being used
	pod2usage(-verbose => 2)
}
if ($versionReq) {
	system('slxversion');
	exit 1;
}

my ($sec, $min, $hour, $day, $mon, $year) = (localtime); $mon++; $year+=1900;
my $callDate = sprintf('%04d-%02d-%02d', $year, $mon, $day);
my $callTime = sprintf('%02d:%02d:%02d', $hour, $min, $sec);

openslxInit();

my $openslxDB = OpenSLX::ConfigDB->new();
$openslxDB->connect();

my $settings = $openslxDB->fetchSettings();

my $clientConfigPath = "$openslxConfig{'private-path'}/config";
if (!-d $clientConfigPath) {
	die _tr("Unable to access client-config-path '%s'!", $clientConfigPath);
}
my $tempPath = "$openslxConfig{'temp-path'}/slxconfig-demuxer";
if (!$dryRun) {
	mkdir $tempPath;
	if (!-d $tempPath) {
		die _tr("Unable to create or access temp-path '%s'!", $tempPath);
	}
}
my $tftpbootPath = $openslxConfig{'tftpboot-path'};
if (!$dryRun) {
	system("rm -rf $tftpbootPath/client-config/* $tftpbootPath/pxe/*");
	system("mkdir -p $tftpbootPath/client-config $tftpbootPath/pxe/pxelinux.cfg");
	if (!-d $tftpbootPath) {
		die _tr("Unable to create or access tftpboot-path '%s'!", $tftpbootPath);
	}
}

my $lockFile = "$tftpbootPath/config-demuxer.lock";
lockScript($lockFile);

END { unlockScript($lockFile); }

writeConfigurations();

my $wr = ($dryRun ? "would have written" : "wrote");
print "$wr $systemConfCount systems and $clientSystemConfCount client-configurations to $tftpbootPath/client-config\n";

$openslxDB->disconnect();

system("rm -rf $tempPath")		unless $dryRun || length($tempPath) < 12;

exit;

################################################################################
###
################################################################################
sub lockScript
{
	my $lockFile = shift;

	return		if $dryRun;

	# use a lock-file to singularize execution of this script:
	if (-e $lockFile) {
		my $ctime = (stat($lockFile))[10];
		my $now = time();
		if ($now - $ctime > 15*60) {
			# existing lock file is older than 15 minutes, wipe it:
			unlink $lockFile;
		}
	}
	if (!sysopen(LOCKFILE, $lockFile, O_RDWR|O_CREAT|O_EXCL)) {
		if ($! == 13) {
			die _tr(qq[Unable to create lock-file <%s>, exiting!\n], $lockFile);
		} else {
			die _tr(qq[Lock-file <%s> exists, script is already running.
Please remove the logfile and try again if you are sure that no one else
is executing this script.\n], $lockFile);
		}
	}
}

sub unlockScript
{
	my $lockFile = shift;

	return		if $dryRun;

	unlink $lockFile;
}

sub writeAttributesToFile
{
	my $attrHash = shift;
	my $fileName = shift;

	return		if $dryRun;

	open(ATTRS, "> $fileName")		or die "unable to write to $fileName";
	my @attrs = sort grep { isAttribute($_) } keys %$attrHash;
	foreach my $attr (@attrs) {
		if (length($attrHash->{$attr}) > 0) {
			my $externalAttrName = externalAttrName($attr);
			print ATTRS "$externalAttrName=$attrHash->{$attr}\n";
		}
	}
	close(ATTRS);
}

sub writeSlxConfigToFile
{
	my $slxConf = shift;
	my $fileName = shift;

	return		if $dryRun;

	open(SLXCONF, "> $fileName")		or die "unable to write to $fileName";
	foreach my $key (sort keys %$slxConf) {
		print SLXCONF qq[$key="$slxConf->{$key}"\n];
	}
	close(SLXCONF);
}

sub copyExternalSystemConfig
{	# copies local configuration extensions of given system from private
	# config folder (var/lib/openslx/config/...) into a temporary folder
	my $systemName = shift;
	my $targetPath = shift;

	return		if $dryRun;

	if ($targetPath !~ m[$tempPath]) {
		die _tr("system-error: illegal target-path <%s>!", $targetPath);
	}
	system("rm -rf $targetPath");
	mkdir $targetPath;

	# first copy default files...
	my $defaultConfigPath = "$clientConfigPath/default";
	if (-d $defaultConfigPath) {
		system("cp -r $defaultConfigPath/* $targetPath")		unless $dryRun;
	}
	# now pour system-specific configuration on top (if any):
	my $systemConfigPath = "$clientConfigPath/$systemName";
	if (-d $systemConfigPath) {
		system("cp -r $systemConfigPath/* $targetPath")		unless $dryRun;
	}
}

sub createTarOfPath
{
	my $buildPath = shift;
	my $tarName = shift;
	my $destinationPath = shift;

	my $tarFile = "$destinationPath/$tarName";
	vlog 1, _tr('creating tar %s', $tarFile);
	return		if $dryRun;

	mkdir $destinationPath;
	my $tarCmd = "cd $buildPath && tar czf $tarFile *";
	if (system("$tarCmd") != 0) {
		die _tr("unable to execute shell-command:\n\t%s \n\t(%s)", $tarCmd, $!);
	}
}

################################################################################
###
################################################################################
sub writePXEMenus
{
	my $pxePath = "$tftpbootPath/pxe";
	my $pxeConfigPath = "$tftpbootPath/pxe/pxelinux.cfg";

	if (!-e "$pxePath/pxelinux.0") {
		my $pxelinux0Path
			= "$openslxConfig{'share-path'}/tftpboot/pxelinux.0";
		system(qq[cp -p "$pxelinux0Path" $pxePath/])		unless $dryRun;
	}
	if (!-e "$pxePath/menu.c32") {
		my $menuc32Path
			= "$openslxConfig{'share-path'}/tftpboot/menu.c32";
		system(qq[cp -p "$menuc32Path" $pxePath/])		unless $dryRun;
	}

	# fetch PXE-template, if any:
	my $pxeTemplate = "# generated by slxconfig-demuxer (on $callDate at $callTime)\n";
	my $pxeTemplateFile = "$openslxConfig{'config-path'}/PXE-template";
	if (-e $pxeTemplateFile) {
		$pxeTemplate .= slurpFile($pxeTemplateFile);
	} else {
		$pxeTemplate .= $pxeDefaultTemplate;
	}
	# PXE uses 'cp850' (codepage 850) but our string is in utf-8, we have
	# to convert in order to avoid showing gibberish on the client side...
	use Encode 'from_to';
	from_to($pxeTemplate, 'utf-8', 'cp850');

	my @clients = $openslxDB->fetchClientByFilter();
	foreach my $client (@clients) {
		my $externalClientID = externalIDForClient($client);
		my $pxeFile = "$pxeConfigPath/$externalClientID";
		my $clientAppend = $client->{kernel_params};
		vlog 1, _tr("writing PXE-file %s", $pxeFile);
		next	if $dryRun;
		open(PXE, ">$pxeFile")		or die "unable to write to $pxeFile";
		print PXE $pxeTemplate;
		my @systemIDs = $openslxDB->aggregatedSystemIDsOfClient($client);
		my @systems = $openslxDB->fetchSystemByID(\@systemIDs);
		foreach my $system (@systems) {
			my $info = $openslxDB->aggregatedSystemFileInfoFor($system);
			my $extSysID = externalIDForSystem($info);
			my $append = $system->{kernel_params};
			$append .= " initrd=$extSysID/initramfs";
			$append .= " $clientAppend";
			$append .= " rootfs=$info->{'export-uri'} file";
			print PXE "LABEL openslx-$extSysID\n";
			print PXE "\tMENU LABEL ^$info->{label}\n";
			print PXE "\tKERNEL $extSysID/kernel\n";
			print PXE "\tAPPEND $append\n";
			print PXE "\tIPAPPEND 1\n";
		}
		close(PXE);
 	}
}

sub generateInitalRamFS
{
	my $setup = shift;
	my $vendorOS = shift;
	my $pxeSysPath = shift;

	vlog 1, _tr('generating initialramfs %s/initramfs', $pxeSysPath);
	my $cmd = "$openslxConfig{'bin-path'}/slxmkramfs ";
	if ($setup->{ramfs_use_busybox}) {
		$cmd .= '-b ';
	}
	my $debugLevel = $setup->{ramfs_debug_level};
	if ($debugLevel) {
		$cmd .= qq[-d $debugLevel ];
	}
	if (length($setup->{ramfs_nicmods}) > 0) {
		$cmd .= qq[-n "$setup->{ramfs_nicmods}" ];
	}
	if (length($setup->{ramfs_fsmods}) > 0) {
		$cmd .= qq[-f "$setup->{ramfs_fsmods}" ];
	}
	my $rootPath
		= "$openslxConfig{'stage1-path'}/$vendorOS->{name}";
	$cmd .= "-i $pxeSysPath/initramfs -r $rootPath ";

	# fill slxConf-hash...
	my %slxConf;
	# ...set date initrd has been generated...
	$slxConf{'slxconf_date'} = $callDate;
	# ...set kernel version...
	my $kernelFile = readlink($setup->{'kernel-file'});
	$kernelFile =~ m[-(.+)$];
	$slxConf{'slxconf_kernver'} = $1;
	# ...set distro version...
	$slxConf{'slxconf_distro'} = $vendorOS->{'name'};
	# ...set list of network modules...
	$slxConf{'slxconf_listnwmod'}
		= $setup->{'ramfs_nicmods'} || $settings->{'default_nicmods'};
	# ...add version info...
	my $slxver = `slxversion`;
	$slxConf{'slxconf_slxver'} = chomp $slxver;
	# ...now create slxsystem.conf file and pass it to slxmkramfs:
	writeSlxConfigToFile(\%slxConf, "$tempPath/slxsystem.conf");
	$cmd .= qq[-s "$tempPath/slxsystem.conf" ];

	$ENV{'SLX_PRIVATE_PATH'} = $openslxConfig{'private-path'};
	$ENV{'SLX_PUBLIC_PATH'} = $openslxConfig{'public-path'};
	$ENV{'SLX_SHARE_PATH'} = $openslxConfig{'share-path'};
	vlog 2, _tr('executing %s', $cmd);
	system($cmd)		unless $dryRun;
}

sub writeSystemPXEFiles
{
	my $system = shift;

	my $info = $openslxDB->aggregatedSystemFileInfoFor($system);
	my $kernelFile = $info->{'kernel-file'};
	my $kernelName = basename($kernelFile);
	my $extSysID = externalIDForSystem($info);

	my $pxePath = "$tftpbootPath/pxe";
	my $pxeSysPath = "$pxePath/$extSysID";
	if (-e $pxeSysPath) {
		die _tr('PXE-system %s already exists!', $pxeSysPath);
	}
	mkdir $pxeSysPath;
	vlog 1, _tr('copying kernel %s to %s/%s', $kernelFile, $pxeSysPath,
				'kernel');
	system(qq[cp -p "$kernelFile" $pxeSysPath/kernel])		unless $dryRun;

	generateInitalRamFS($info, $info->{'vendor-os'}, $pxeSysPath);
}

sub writeDhcpConfig
{
	return unless defined $dhcpType;
vlog 0, _tr("sorry, exporting dhcp data is not done yet!");
	my $dhcpModule = "OpenSLX::Export::DHCP::$dhcpType";
	if (!eval "require $dhcpModule") {
		die _tr("unable to load DHCP-Export backend '%s'! (%s)\n", $dhcpModule, $@);
	}
	my $dhcpBackend = $dhcpModule->new();
	my @clients = $openslxDB->fetchClientByFilter();
	$dhcpBackend->execute(\@clients);
}

sub writeClientConfigurationsForSystem
{
	my $system = shift;
	my $buildPath = shift;
	my $attrFile = shift;

	my @clientIDs = $openslxDB->aggregatedClientIDsOfSystem($system);
	my @clients = $openslxDB->fetchClientByID(\@clientIDs);
	foreach my $client (@clients) {
		vlog 2, _tr("exporting client %d:%s", $client->{id}, $client->{name});
		$clientSystemConfCount++;

		# merge configurations of client, it's groups, default client and
		# system and write the resulting attributes to a configuration file:
		$openslxDB->mergeDefaultAndGroupAttributesIntoClient($client);
		mergeAttributes($client, $system);
		writeAttributesToFile($client, $attrFile);

		# create tar containing external system configuration
		# and client attribute file:
		my $externalClientID = externalIDForClient($client);
		my $externalSystemID = externalIDForSystem($system);
		createTarOfPath($buildPath, "${externalClientID}.tgz",
						"$tftpbootPath/client-config/$externalSystemID");
	}
}

sub writeSystemConfigurations
{
	my @systems = $openslxDB->fetchSystemByFilter();
	foreach my $system (@systems) {
		next 	unless $system->{id} > 0;

		vlog 0, _tr('exporting system %d:%s', $system->{id}, $system->{name});
		$systemConfCount++;

		my $buildPath = "$tempPath/build";
		copyExternalSystemConfig($system->{name}, $buildPath);

		my $attrFile = "$buildPath/initramfs/machine-setup";
		$openslxDB->mergeDefaultAttributesIntoSystem($system);
		writeAttributesToFile($system, $attrFile);

		my $externalSystemID = externalIDForSystem($system);
		my $systemPath = "$tftpbootPath/client-config/$externalSystemID";
		createTarOfPath($buildPath, "default.tgz", $systemPath);

		writeSystemPXEFiles($system);

		writeClientConfigurationsForSystem($system, $buildPath, $attrFile);

		system("rm -rf $buildPath")		unless $dryRun;
	}
}

sub writeConfigurations
{
	$systemConfCount = $clientSystemConfCount = 0;
	writeSystemConfigurations();
	writePXEMenus();
	writeDhcpConfig();
}

__END__

=head1 NAME

slxconfig-demuxer - OpenSLX configuration demultiplexer

=head1 SYNOPSIS

slxconfig-demuxer [options]

=head3 Script Options

    --dhpc-type=<string>       specifies the type of DHCP-server
                               (ISC,...)
    --dry-run                  avoids writing anything, for testing

=head3 General Options

    --help                     brief help message
    --man                      full documentation
    --version                  show version

=head1 DESCRIPTION

B<slxconfig-demuxer> will read information about all systems, clients and
groups from the OpenSLX configuration database, mix & match the individual
configurational attributes and then demultiplex the resulting information
to a set of configuration files. These files are used by any OpenSLX-client
during boot to find out which systems to offer for booting.

The resulting files will be put into the OpenSLX-tftpboot-path (you can use the
option B<--tftpboot-path> to override the default taken from the OpenSLX
default settings).

=head2 FILE CREATION

The following set of files will be created:

=over 8

=item B<Basic PXE Setup>

The basic PXE files (F<menu.c32>, F<pxelinux.0>) will be copied into
F<$SLX_TFTPBOOT_PATH/pxe> to make them available to any PXE-client via tftp.

=item B<PXE Client Configurations>

For each client, a PXE configuration file will be generated and written to
F<$SLX_TFTPBOOT_PATH/pxe/pxelinux.cfg/01-<MAC-of-client>>. This file will
contain information about the systems this client shall offer for booting.
For each of these systems, the kernel cmdline options required for that
particular system setup is specified (via PXE's APPEND option).

=item B<System Kernels and Initialram-Filesystems>

For each bootable system, that system's kernel will be copied to
F<$SLX_TFTPBOOT_PATH/pxe/<system-name>/kernel and an OpenSLX-specific initramfs
required for booting that particular system is generated (by means of
slxmkramfs) and put into F<$SLX_TFTPBOOT_PATH/pxe/<system-name>/initramfs.

These two files (kernel & initramfs) will be referenced by the PXE client
configuration of all clients that offer this specific system for booting.

=item B<OpenSLX Client Configurations>

For each combination of system and client, an OpenSLX configuration archive
will be generated and written to
F<$SLX_TFTPBOOT_PATH/client-config/<system-name>/01-<MAC-of-client>.tgz>.
This archive will contain the file F<initramfs/machine-setup>, specifying all
the attributes of that particular client (e.g. whether or not it should start
the X-server).

Furthermore, the archive may contain additional system files that are
required for the client (e.g. a special PAM-module required for LDAP
authentication). These files are copied from F<$SLX_PRIVATE_PATH/config/default>
and F<$SLX_PROVATE_PATH/config/<system-name>>.

=back

=head2 MIXING & MATCHING (THE DEMUXER)

In the OpenSLX configuration database, each system, group and client may have
several configurational attributes set to a specific value that will cause
a client booting that system to behave in a certain way. The mixing of all
these different attributes into one set that is relevant for a specific client
booting one specific system is one important task of the slxconfig-demuxer.

As an example, let's assume one system setup that is configured to boot directly
into a special application that demands a rather low screen-resolution of
1024x768 pixels, as otherwise the text would be unreadable due to very small
fonts being used by that app. In order to achieve this, the administrator can
set the I<hw_monitor>-attribute of the B<system> to '1024x768'.
Let's say one of the clients, however, is connected to a very old monitor that
has problems with this resolution and only supports 800x600 pixels. In that
case, the administrator can set the I<hw_monitor>-attribute of that B<client> to
'800x600'. The mixing & matching process would make sure that this specific
client would run that system with a resolution of 800x600, while all other
clients would run that system in 1024x768.

So the slxconfig-demuxer demultiplexes the individual configurational attributes
into a concrete set of configuration settings for specific clients and their
offered systems, making sure that each client/system combination uses the
appropriate settings.

=head1 OPTIONS

=head3 Script Options

=over 8

=item B<<     --dhcp-export-type >>

Specifies the type of DHCP-export that shall be used. Currently, only 'ISC' is
supported.

=item B<<     --dry-run >>

Runs the script but avoids writing anything. This is useful for testing, as
you can learn from the logging output what would have been done.

=back

=head3 General Options

=over 8

=item B<<     --help >>

Prints a brief help message and exits.

=item B<<     --man >>

Prints the manual page and exits.

=item B<<     --version >>

Prints the version and exits.

=back

=head1 SEE ALSO

slxsettings, slxos-setup, slxos-export, slxconfig

=head1 GENERAL OPENSLX OPTIONS

Being a part of OpenSLX, this script supports several other options
which can be used to overrule the OpenSLX settings:

    --base-path=<string>       basic path to project files
    --bin-path=<string>        path to binaries and scripts
    --config-path=<string>     path to configuration files
    --db-basepath=<string>     basic path to openslx database
    --db-datadir=<string>      data folder created under db-basepath
    --db-name=<string>         name of database
    --db-spec=<string>         full DBI-specification of database
    --db-type=<string>         type of database to connect to
    --export-path=<string>     path to root of all exported filesystems
    --locale=<string>          locale to use for translations
    --logfile=<string>         file to write logging output to
    --private-path=<string>    path to private data
    --public-path=<string>     path to public (client-accesible) data
    --share-path=<string>      path to sharable data
    --stage1-path=<string>     path to stage1 systems
    --temp-path=<string>       path to temporary data
    --tftpboot-path=<string>   path to root of tftp-server
    --verbose-level=<int>      level of logging verbosity (0-3)

Please refer to the C<slxsettings>-manpage for a more detailed description
of these options.

=cut

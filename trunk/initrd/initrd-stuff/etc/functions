# common function script for the configuration of linux diskless clients
# (included by init, hwautocfg, servconfig, ... within OpenSLX initial 
# ramfs) 
#
# Dirk von Suchodoletz <dvs@OpenSLX.com>, 31-08-2006
# Felix Endres, 30-04-2006
# Tobias Maier
#
# (c) 2006 - RZ Universitaet Freiburg
# (c) 2006 - OpenSLX.ORG Project

#######################################################################
# set of empty dummy functions (loaded before real functions in the 
# distro specific files - to have no undeclared function in init, serv-
# config, hwautocfg, ...

# distro specific funtion called at the beginning of init script
preinit () {
  :
}
# distro specific funtion called at the end of init script
postinit () {
  :
}
# distro specific general function called from servconfig script
config_distro () {
  :
}
# udev/hotplug - auto device discovery service
udev_hotplug () {
 : 
}


#######################################################################
# generate events with the sysfs trigger
trigger_device_events () {
  list=$(echo /sys/bus/*/devices/*/uevent)
  list="$list $(echo /sys/class/*/*/uevent)"
  list="$list $(echo /sys/block/*/uevent /sys/block/*/*/uevent)"
  for i in $list; do
    case "$i" in
      */device/uevent|*\**)
        continue
      ;;
      */class/mem/*|*/class/tty/*)
        first="$first $i"
      ;;
      */block/md*)
        last="$last $i"
      ;;
      */*)
        default="$default $i"
      ;;
    esac
  done
  # trigger the sorted events
  for i in $first $default $last; do
    echo "add" > "$i"
  done
}

#######################################################################
# produce error message and if $2 is empty run (debug) shell 
error () {
local e_msg="$1"
# check if LOGFILE is really writeable
if [ -n "${LOGFILE}" ] ; then
  [ "${LOGFILE}" != "/dev/null" ] && \
  [ -w /mnt/${LOGFILE} ] || LOGFILE="/dev/null"
else LOGFILE="/dev/null"
fi
# if nonfatal error else fatal error message and shell
if [ -n "$2" ] ; then
  [ "$DEBUGLEVEL" -ge 1 ] && echo -e "${error_msg}${e_msg}${error_nfe}" \
      >> ${LOGFILE} 
  [ "$DEBUGLEVEL" -gt 1 ] && echo -e "${error_msg}${e_msg}${error_nfe}"
  [ "$DEBUGLEVEL" -gt 2 ] && usleep 20
else
  echo -e "${error_msg}${e_msg}${error_shell}"
  # load usb modules to have keyboard enabled - they might have to be
  # copied into initramfs with mkdxsinitramfs ...
  modprobe -a usbcore uhci-hcd ohci-hcd usbhid 2>&1 >/dev/null
  /bin/sh
  echo -n "Reboot now? [y]"
  read input
#  [ -z "$input" -o "$input" = "y" -o "$input" = "Y" ] && {
#    usleep 100
#    [ -f /proc/sysrq-trigger ] || mount -t proc none /proc
#    echo "b" > /proc/sysrq-trigger
#  }
fi
}

#######################################################################
# micro sleep - either busybox command or simply loop and delete 1 from 
# the first argument gotten until zero
usleep () {
if [ -x /bin/usleep ]; then
  /bin/usleep `expr $1 \* 60000`
else
  local count=`expr $1 \* 10`
  while [ $count -gt 0 ] ; do count=`expr $count \- 1` ; done
fi
return 0
}
#######################################################################
# (re)generate dynamic linked libraries cache from /etc/ld.so.conf
ldcfg () {
[ -z "${NOLDSC}" ] && echo "$init_ldcfg" && ldconfig /tmp/ld.so.cache &
}
#######################################################################
# URI interpreter $1 variable to interprete, $2 type of token to return
# prot: tftp, http, nbd, ... server: IP or FQDN 
uri_token () {
local var=$1
# first check if URI starts with prot:// - URI scheme
if strinstr "://" "$1" ; then
  prot=${var%://*}
  rest=${var#*://}
else
  rest="$var"
  prot=""
fi
# get the server IP or name and port - URI authority 
# you get the path or other token without leading "/" - add it later if
# needed (fixme: port might be broken)
if strinstr ":" "$rest" ; then
  server="${rest%:*}"
  rest="${rest#*:}"
  path="${rest#*/}"
  port="${rest%/$path}"
else
  tmpval=$rest
  rest="${rest#*/}"
  server="${tmpval%/*}"
  path="${tmpval#*/}"
  port=""
fi
# get path and query components - URI path, query
query=""
if strinstr "\?" "$rest" ; then
  path="${path%\?*}"
  query="${rest#*\?}"
fi
# return the requested token
case "$2" in
  prot) echo "$prot" ;;
  server) echo "$server" ;;
  path) echo "$path" ;;
  port) echo "$port" ;;
  query) echo "$query" ;;
esac
}
#######################################################################
# load a certain module - name of module with path in argument one, the
# error message in second argument
loadmod () {
local modpath=$1
local module=`echo $modpath|sed -e "s,.*/,,"`
local msg=$2
if [ -f $modpath ] ; then
  module=${module%.*}
  modprobe ${MODPRV} ${module#*.} || \
    echo "$error_modload '$module'. $msg"
fi
}
#######################################################################
# compute prefix bit number from netmask
nm2pref () {
set `IFS="."; echo $1`
local n=0
  for i in $1 $2 $3 $4 ; do
    case $i in
        0) break ;;
      128) n=`expr $n + 1` ; break ;;
      192) n=`expr $n + 2` ; break ;;
      224) n=`expr $n + 3` ; break ;;
      240) n=`expr $n + 4` ; break ;;
      252) n=`expr $n + 6` ; break ;;
      254) n=`expr $n + 7` ; break ;;
      255) n=`expr $n + 8` ; continue ;;
    esac
  done
echo $n
}
#######################################################################
# configure IP address statically - first argument the ip address, 
# second the netmask, then gateway and broadcast address and last
# interface. All arguments have to be given.
ipsetup () {
local ip=$1
local nm=$2
local gw=$3
local bc=$4
local if=$5
for ipcfg in ip ipconfig ifconfig none; do
  test -x /bin/$ipcfg && break;
done
case $ipcfg in
  ip)
    ip link set dev $if up
    ip addr add $ip/`nm2pref $nm` broadcast $bc dev $if
    if [ "$gw" != "0.0.0.0" ] ; then
      ip route add default via $gw
    fi
    MAC=$(ip link show dev $if|sed -n "/ether [0-9e-f]\{2\}:.*/p" \
      | sed -e "s/.*ether //;s/ .*//")
  ;;
  ipconfig)
    # fixme: to be checked
    ipconfig $ip::$gw:$nm:$if:none
    MAC=""
  ;;
  ifconfig)
    if [ "$ip" = "0.0.0.0" ]; then
      ifconfig $if up
    else
      ifconfig $if $ip netmask $nm broadcast $bc
    fi
    [ "$gw" != "0.0.0.0" ] && route add default gw $gw
    MAC=$(ifconfig $if|sed -n "/HWaddr [0-9A-F]\{2\}:.*/p" \
      | sed -e "s/.*HWaddr //;y/ABCDEF/abcdef/")
  ;;
  none)
    error "$error_iptool"
  ;;
esac
}
#######################################################################
# nfs mounter for root filesystem and other sources
nfsmnt ()
{
local nfsroot=$1
local dest=$2
local ret=0
[ -z "$dest" ] && dest="/mnt"
for mnt in nfsmount mount none; do
  test -x /bin/$mnt && break;
done
[ -f /lib/modules/@@@KERNVER@@@/kernel/fs/nfs/nfs.ko ] && \
  loadmod /lib/modules/@@@KERNVER@@@/kernel/fs/nfs/nfs.ko "$error_modnfs"
case $mnt in
  nfsmount)
    nfsmount -o ro $nfsroot $dest || ret=1
  ;;
  mount)
    portmap || { echo "$error_portm"; ret=1; }
    # fixme: busybox mount uses nfs ...
    mount -n -t nfs -o ro,nolock $nfsroot $dest || ret=1
    killall -9 portmap
  ;;
  none)
    error "$error_mntt"
  ;;
esac
return $ret
}
#######################################################################
# create configuration file for dhclient
mkdhclconf () {
local vci=$1
# provide dhclient with proper configuration
echo -e "option bootlocal-script code 221\t= string;\n\
option language code 222\t\t= string;\n\
option start-x code 223\t\t\t= string;\n\
option start-snmp code 224\t\t= string;\n\
option start-sshd code 225\t\t= string;\n\
option start-xdmcp code 226\t\t= string;\n\
option start-cron code 227\t\t= string;\n\
option crontab-entries code 228\t\t= string;\n\
option start-rwhod code 229\t\t= string;\n\
option start-printdaemon code 230\t= string;\n\
option desktop-session code 231\t\t= string;\n\
option tex-enable code 232\t\t= string;\n\
option netbios-workgroup code 233\t= string;\n\
option vmware code 234\t\t\t= string;\n\
option hw-mouse code 252\t\t= string;\n\
option hw-graphic code 253\t\t= string;\n\
option hw-monitor code 254\t\t= string;\n\n\
send dhcp-lease-time 86400;\nsend dhcp-max-message-size 1400;\n\
request;\nscript \"/bin/dhclient-script\";" >> /etc/dhclient.conf
if [ -n "$vci" ] ; then
  echo "send vendor-class-identifier \"$vci\";" >> /etc/dhclient.conf
fi
}

#######################################################################
# dhcp client
rundhcp ()
{
local vci="$1"
for dhcp in dhclient dhcpcd pump ipconfig udhcpc none; do
  test -e /bin/$dhcp && break;
done
if [ "$dhcp" = "none" ] ; then
  error "$error_nodhcp" nonfatal
else
  # ensure the interface is up
  ipsetup 0.0.0.0 255.255.255.255 0.0.0.0 255.255.255.255 eth0 &
  [ -f /lib/modules/@@@KERNVER@@@/kernel/net/packet/af_packet.ko ] && \
    loadmod /lib/modules/@@@KERNVER@@@/kernel/net/packet/af_packet.ko \
      "needed for dhcp";
  echo "Starting $dhcp for configuration"
  mkdir /var/lib/dhcp 2>&1 >/dev/null
fi
export client="$dhcp"
case $dhcp in
  dhclient)
    mkdhclconf $vci
    ln -s /bin/dhcpmkconfig /bin/dhclient-script
    dhclient -cf /etc/dhclient.conf -lf /var/lib/dhcp/dhclient.leases \
      -q eth0 2>&1 >/dev/null || error "$error_dhclient"
  ;;
  dhcpcd)
    [ -n $vci ] && vci="-i $vci"
    ln -s /bin/dhcpmkconfig /bin/dhcpcd.exe
    dhcpcd $vci -L /var/lib/dhcp -c /bin/dhcpcd.exe -T -t 30 eth0 \
     2>&1 >/dev/null || error "$error_dhcpcd"
  ;;
  pump)
      error "$error_pump"
  ;;
  ipconfig)
      [ $DEBUGLEVEL -gt 1 ] && echo -e "# You are using ipconfig as dhcp \
client. With this tool you only get the\n# basic IP settings from the \
server. No vendor specific, self defined\n# dhcp options are possible this \
way. use dhclient instead or get them via\n# tftp (to be enabled via kernel \
command line)." >> /etc/machine-setup
      error "$error_ipconf"
  ;;
  # udhcpc is part of busybox
  udhcpc)
    [ -n $vci ] && vci="-V $vci"
    ln -s /bin/dhcpmkconfig /bin/udhcpc.script
    udhcpc -b -q $vci -s /bin/udhcpc.script -i eth0
  ;;
  *)
  ;;
esac
echo "dhcp finished" > /tmp/dhcp-done
}

#######################################################################
# function for retrieving configuration file (machine-setup) via tftp
# from a predefined server or given source (file=tftp-server:/path via
# kernel command line)
# tftpget is helper function for fileget 
tftpgetunpack () {
# $1 is  config file name to get, $2 IP of server to get file from
for tftp in /bin/atftp /bin/tftp ; do
  test -x $tftp && break
done
echo -e "tftp\t69/tcp\ntftp\t69/udp" > /etc/services
local dst=/tmp/$(basename $1)
# tftp get part
case "$tftp" in
    */atftp)
      atftp -g -r $1 -l $dst $2 2> /dev/null
    ;;
    */tftp)
      # distinguish between busybox tftp and standalone (in.tftp) client
      if [ -x /bin/busybox ] ; then
        tftp -g -r $1 -l $dst $2 1>&2 >/dev/null
      else
        echo "get $1 $dst" | tftp $2 1>&2 >/dev/null 
      fi
    ;;
esac
# unpack part (only gzip is supported)
if [ -s $dst ] ; then
  tar -xpzf $dst 2>/dev/null
  [ "$DEBUGLEVEL" -le 2 ] && rm $dst
  return 0
else
  return 1
fi
}
fileget () {
# get type of tftp available, alternatively use wget for ftp or http 
# (fixme: rewrite of fileget needed!!)
# analyze file soure (URI) in $FILESRC
if [ -n "$FILESRC" ] ; then
  srvproto=$(uri_token $FILESRC prot)
  cfgfile="/$(uri_token $FILESRC path)"
  tftpserver=$(uri_token $FILESRC server)
  tftpgetunpack $tftp $cfgfile $tftpserver
else
  cfgdir="/tftpboot/client-config/"
  local tftpserver=$serverip
  # try to get configuration files successively; start with distro client
  # and try last distro default ...
  echo -e "\n## Configuration via fileget: Hierarchy is distro client \
and as last\n# distro/default" >> /tmp/confviafile
  mac=$(echo $MAC|sed "s/:/-/g")
  for cfgfile in $cfgdir/$DISTRO/01-$mac.tgz $cfgdir/$DISTRO/default.tgz \
                 $cfgdir/01-$mac.tgz $cfgdir/default.tgz ; do
    tftpgetunpack $cfgfile $tftpserver && break
  done
fi
test -f /initramfs/machine-setup && \
  cat /initramfs/machine-setup >> /tmp/confviafile
echo "fileget via $srvproto finished" > /tmp/file-done
}

#######################################################################
# function for creating directories after testing of their existance
# avoids to recreate directories in union mounts
testmkd () {
  test -d $1 || mkdir -p $1 &>/dev/null
}

#######################################################################
# simple basename replacement
basename () {
  local b=${1##*/}
  echo ${b%$2}
}

#######################################################################
# simple string in string search 
strinstr (){
  case "$2" in *$1*) return 0;; esac
  return 1
}

#######################################################################
# simple string in file search 
strinfile (){
  case "$(cat $2)" in *$1*) return 0;; esac
  return 1
}


#######################################################################
# Check boot commandline for specified option
inkernelcmdline (){
strinstr " $1" "${KCMDLINE}"
return "$?"
}

#######################################################################
# wait for a file to appear and stop after maxwait counts
waitfor () {
local file=$1
local maxwait=$2
local count=0
while [ ! -e $file ] ; do
  echo "waiting ........." > /dev/null
  count=`expr $count + 1`
  [ $count -gt $maxwait ] && return 1
done
return 0
}

#######################################################################
# search for ldconfig and execute it
# check that /mnt/etc/ld.so.conf is never lost
ldconfig () {
local cachefile="$1"
for ldcfg in /mnt/sbin/ldconfig \
             /mnt/bin/ldconfig \
             /mnt/usr/sbin/ldconfig; do
  test -x $ldcfg && {
    $ldcfg -r /mnt -C $cachefile; break; }
done
#/mnt/sbin/ldconfig -r /mnt -C $cachefile
echo "finished" > /tmp/ldcfg
}

#######################################################################
# configuration via ldap
ldapconf () {
local ldapserver=$1
error "$error_ldapcfg"
echo "not implemented" > /tmp/ldap-done
} 

#######################################################################
# base passwd/shadow, the standard user present in every system. All
# other system users should be generated within the service function
basepasswd () {
# strip every line with userid between 500 and 99999 from the passwd
# file
sed '/^[a-zA-Z0-9]*:[a-zA-Z0-9]*:[1-9][0-9]\{3,4\}:/d;/^+:*/d;/^+$/d;
  /^[a-zA-Z0-9]*:[a-zA-Z0-9]*:[5-9][0-9]\{2\}:/d' /mnt/etc/passwd \
  > /tmp/newpasswd
# and add user nobody again (is there a more elegant way?)
sed -n -e '/nobody/p' /mnt/etc/passwd >> /tmp/newpasswd
cp /tmp/newpasswd /mnt/etc/passwd
# create the shadow from passwd file
echo -e "root:"$root_pw":12958:0:10000::::" > /mnt/etc/shadow
sed 's/:.*/:!:13078:0:99999:7:::/;/^root.*/d' /tmp/newpasswd \
  >> /mnt/etc/shadow
}

#######################################################################
# wait for the completion of configuration file (machine-setup). It is
# composed from different sources
cfgcomplete () {
waitfor /tmp/dhcp-done 10000 || error "$error_errdcfg" nonfatal
waitfor /tmp/file-done 10000 || error "$error_errfcfg" nonfatal
waitfor /tmp/ldap-done 10000 || error "$error_errlcfg" nonfatal
# concat the different files now into the central config file, order
# matters - ldap data has highest priority
if ! [ -f /tmp/cfgcomplete ] ; then
  for config in /tmp/confviadhcp /tmp/confviafile /tmp/confvialdap
    do test -f $config && cat $config >> /etc/machine-setup
  done
echo "config completed" > /tmp/cfgcomplete
fi
}

#######################################################################
# localization simply derived from $language variable set in 
# machine-setup or other sources - mostly taken from knoppix
localization () {
country="$1"
CONSOLE_FONT="lat9w-16.psfu"
case "$country" in
  # German version
  de*)
    COUNTRY="de"
    LANG="de_DE.UTF8"
    KEYTABLE="de-latin1-nodeadkeys"
    XKEYBOARD="de"
    KDEKEYBOARD="de"
    CHARSET="utf8"
    KDEKEYBOARDS="us,fr"
    TZ="Europe/Berlin"
  ;;
  # Belgian version
  be*)
    COUNTRY="be"
    LANG="C"
    KEYTABLE="be2-latin1"
    XKEYBOARD="be"
    KDEKEYBOARD="be"
    CHARSET="iso8859-15"
    KDEKEYBOARDS="us,de,fr"
    TZ="Europe/Brussels"
  ;;
  # Bulgarian version
  bg*)
    COUNTRY="bg"
    LANG="bg_BG"
    KEYTABLE="bg"
    XKEYBOARD="bg"
    KDEKEYBOARD="bg"
    CHARSET="microsoft-cp1251"
    KDEKEYBOARDS="us,de,fr"
    TZ="Europe/Sofia"
  ;;
  # Switzerland (basically de with some modifications)
  ch)
    LANGUAGE="de"
    COUNTRY="ch"
    LANG="de_CH"
    KEYTABLE="sg-latin1"
    XKEYBOARD="de_CH"
    KDEKEYBOARD="de_CH"
    CHARSET="iso8859-15"
    KDEKEYBOARDS="de,us,fr"
    TZ="Europe/Zurich"
  ;;
  # Simplified Chinese
  cn)
    COUNTRY="cn"
    LANG="zh_CN.GB2312"
    KEYTABLE="us"
    XKEYBOARD="us"
    KDEKEYBOARD="us"
    CHARSET="gb2312.1980-0"
    KDEKEYBOARDS="us,de,fr"
    XMODIFIERS="@im=Chinput"
    TZ="Asia/Shanghai"
  ;;
  # Czechoslovakia
  cs|cz)
    LANGUAGE="cs"
    COUNTRY="cs"
    LANG="cs_CZ"
    KEYTABLE="cz-lat2"
    XKEYBOARD="cs"
    KDEKEYBOARD="cz"
    CHARSET="iso8859-2"
    KDEKEYBOARDS="us,de,fr"
    TZ="Europe/Prague"
    CONSOLE_FONT="iso02g"
  ;;
  # Denmark
  dk|da)
    COUNTRY="dk"
    LANG="da_DK"
    # Workaround: "dk" broken in gettext, use da:da_DK
    LANGUAGE="da:da_DK"
    KEYTABLE="dk"
    XKEYBOARD="dk"
    KDEKEYBOARD="dk"
    CHARSET="iso8859-15"
    KDEKEYBOARDS="dk,de,us,fr"
    TZ="Europe/Copenhagen"
  ;;
  es)
  # Spain
    COUNTRY="es"
    LANG="es_ES@euro"
    KEYTABLE="es"
    XKEYBOARD="es"
    KDEKEYBOARD="es"
    CHARSET="iso8859-15"
    KDEKEYBOARDS="de,us,fr"
    TZ="Europe/Madrid"
  ;;
  # Finland
  fi)
    COUNTRY="fi"
    LANG="fi_FI@euro"
    KEYTABLE="fi"
    XKEYBOARD="fi"
    KDEKEYBOARD="fi"
    CHARSET="iso8859-15"
    KDEKEYBOARDS="us"
    TZ="Europe/Helsinki"
  ;;
  # France
  fr*)
    COUNTRY="fr"
    LANG="fr_FR@euro"
    KEYTABLE="fr"
    XKEYBOARD="fr"
    KDEKEYBOARD="fr"
    CHARSET="iso8859-15"
    KDEKEYBOARDS="de,us"
    TZ="Europe/Paris"
  ;;
  he|il)
  # Hebrew version
    LANGUAGE="he"
    COUNTRY="il"
    LANG="he_IL"
    KEYTABLE="us"
    XKEYBOARD="us"
    KDEKEYBOARD="il"
    CHARSET="iso8859-8"
    KDEKEYBOARDS="us,fr,de"
    TZ="Asia/Jerusalem"
  ;;
  # Ireland
  ie)
    COUNTRY="ie"
    LANG="en_IE@euro"
    KEYTABLE="uk"
    XKEYBOARD="uk"
    KDEKEYBOARD="gb"
    CHARSET="iso8859-15"
    KDEKEYBOARDS="us,de,es,fr,it"
    TZ="Europe/Dublin"
  ;;
  # Italy
  it)
    COUNTRY="it"
    LANG="it_IT@euro"
    KEYTABLE="it"
    XKEYBOARD="it"
    KDEKEYBOARD="it"
    CHARSET="iso8859-15"
    KDEKEYBOARDS="fr,us,de"
    TZ="Europe/Rome"
  ;;
  # Japan
  ja)
    COUNTRY="jp"
    LANG="ja_JP"
    LANGUAGE="ja"
    KEYTABLE="us"
    XKEYBOARD="us"
    KDEKEYBOARD="us"
    CHARSET="iso8859-15"
    KDEKEYBOARDS="fr,us,de"
    TZ="Asia/Tokyo"
  ;;
  # The Netherlands
  nl)
    COUNTRY="nl"
    LANG="nl_NL@euro"
    KEYTABLE="us"
    XKEYBOARD="us"
    KDEKEYBOARD="en_US"
    CHARSET="iso8859-15"
    KDEKEYBOARDS="nl,de,fr"
    TZ="Europe/Amsterdam"
  ;;
  # Poland
  pl)
    COUNTRY="pl"
    LANG="pl_PL"
    KEYTABLE="pl"
    XKEYBOARD="pl"
    KDEKEYBOARD="pl"
    CHARSET="iso8859-2"
    KDEKEYBOARDS="de,us,fr"
    TZ="Europe/Warsaw"
    CONSOLE_FONT="iso02g"
  ;;
  # Russia
  ru)
    COUNTRY="ru"
    LANG="ru_RU.KOI8-R"
    KEYTABLE="ru"
    XKEYBOARD="ru"
    KDEKEYBOARD="ru"
    CHARSET="koi8-r"
    CONSOLE_FONT="Cyr_a8x16"
    KDEKEYBOARDS="de,us,fr"
    TZ="Europe/Moscow"
  ;;
  # Slovakia
  sk)
    COUNTRY="sk"
    LANG="sk"
    KEYTABLE="sk-qwerty"
    XKEYBOARD="sk"
    KDEKEYBOARD="sk"
    CHARSET="iso8859-2"
    KDEKEYBOARDS="us,de"
    TZ="Europe/Bratislava"
    CONSOLE_FONT="iso02g"
  ;;
  # Slovenia
  sl)
    LANGUAGE="sl"
    COUNTRY="si"
    LANG="sl_SI"
    KEYTABLE="slovene"
    XKEYBOARD="sl"
    KDEKEYBOARD="si"
    CHARSET="iso8859-2"
    KDEKEYBOARDS="us,de"
    TZ="Europe/Ljubljana"
    CONSOLE_FONT="iso02g"
  ;;
  tr)
# Turkish version (guessed)
    COUNTRY="tr"
    LANG="tr_TR"
    KEYTABLE="tr_q-latin5"
    XKEYBOARD="tr"
    KDEKEYBOARD="tr"
    CHARSET="iso8859-9"
    KDEKEYBOARDS="us,de,fr"
    TZ="Europe/Istanbul"
  ;;
  # Taiwan - Traditional Chinese version (thanks to Chung-Yen Chang)
  tw)
    COUNTRY="tw"
    LANG="zh_TW.Big5"
    LANGUAGE="zh_TW.Big5"
    KEYTABLE="us"
    XKEYBOARD="us"
    KDEKEYBOARD="us"
    CHARSET="iso8859-1"
    KDEKEYBOARDS="us"
    XMODIFIERS="@im=xcin"
    TZ="Asia/Taipei"
  ;;
  # Great Britian
  uk)
    COUNTRY="uk"
    LANG="en_GB"
    LANGUAGE="en"
    KEYTABLE="uk"
    XKEYBOARD="uk"
    KDEKEYBOARD="gb"
    CHARSET="iso8859-1"
    KDEKEYBOARDS="us"
    TZ="Europe/London"
  ;;
  # US and default configuration
  *)
    LANGUAGE="us"
    COUNTRY="us"
    LANG="C"
    KEYTABLE="us"
    XKEYBOARD="us"
    KDEKEYBOARD="us"
    CHARSET="iso8859-1"
    KDEKEYBOARDS="de,fr"
    TZ="America/New_York"
  ;;
esac
}
#######################################################################
# setup initial boot scripts (for most standard distributions, gentoo
# is to be handled differently)
initial_boot () {
for i in ${D_RCDIRS} ${D_INITBOOTD} ; do
  rm -f /mnt/etc/$i/*
done
count=10
# boot.ld is a special runlevel script generated within initial ramdisk
# which should be executed before the rest
for i in boot.ld ${D_INITSCRIPTS}; do 
  count=`expr $count + 1`
  revcnt=`expr 41 - $count`
  ln -sf /etc${D_INITDIR}/$i /mnt/etc/${D_INITBOOTD}/S${count}$i
  ln -sf /etc${D_INITDIR}/$i /mnt/etc/${D_INITBOOTD}/K${revcnt}$i
done
}
#######################################################################
# find out if prerequisites for special X server modules are met
# incomplete
check_glx () {
case "${XMODULE}" in
  radeon)
    # check ${XDESC}/ hwsetup.info device string in Cards file and then 
    # for needed components
    test -f /mnt/lib/modules/${KERNEL}/kernel/drivers/char/drm/fglrx.ko \
      && test -f /mnt/usr/X11R6/lib/modules/drivers/fglrx_drv.o && \
         XMODULE=fglrx
      # there seems no problem, if no TV is connected
      TVOUT='\tOption\t\t"TVFormat" "PAL-B"\n
\tOption\t\t"DesktopSetup" "horizontal"'
  ;;
  nv)
    #
    # test -f /mnt/usr/X11R6/lib/modules/drivers/nvidia_drv.o
  ;;
esac
}

#######################################################################
# dummy functions - avoid undefined functions in servconfig (functions
# are normally overwritten by settings within distro-functions - a file
# generated by mkdxsconfig from <distro>/functions-default & ~-version

# overwrite xorg configuration set by hwautocfg
displayvars (){
:
}

# function for ntp configuration
config_ntp () {
 : 
}

# function for atd
config_atd () {
 : 
}

# function for configuration of cron services
config_cron () {
 : 
}

# syslog service
config_syslog () {
 : 
}

# secure shell service
config_sshd () {
 :
}

# snmp agent for remote monitoring
config_snmp () {
 : 
}

# consolefont
consolefont () {
 : 
}
# acpi and powersave
config_acpi () {
 : 
}

# configure xdm as display manager
config_xdm () {
  :
} 

# configure gdm as display manager
config_gdm () {
 : 
}

# configure hal, dbus, resmgr and services like that
config_dreshal () {
  :
}

# configure automounter
config_automount () {
:
}

# configure bluetooth services
config_bt () {
:
}

d_mkrlscript () {
 : 
}

# start name service caching daemon
config_nscd () {
:
}

# prepare virtual machine environment (vmware, vmplayer)
config_vmware () {
 : 
}

# configure automounter
config_automount () {
 : 
}

# start portmapper (needed at least for nfs and nis services)
config_portmap () {
:
}

# start NIS (fixmee - does the service is really named ypbind??)
config_nis () {
 :
}

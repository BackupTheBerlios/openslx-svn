#!/bin/ash
# Copyright (c) 2008..2009 - OpenSLX GmbH
#
# This program is free software distributed under the GPL version 2.
# See http://openslx.org/COPYING
#
# If you have any feedback please consult http://openslx.org/feedback and
# send your feedback to feedback@openslx.org
#
# General information about OpenSLX can be found at http://openslx.org
#
# Main script for preboot initial ramfs - preloading environment for running
# OpenSLX linux stateless clients version 5 for testing

fetchip () {
# we expect to get an ip address within 10++ seconds
( sleep 6 ; killall udhcpc >/dev/null 2>&1 ) &
for i in 1 2 ; do
  udhcpc -f -n -q $vci -s /usr/share/udhcpc/default.script -i $nwif 2>/dev/null
  if grep "ip=" /tmp/ipstuff >/dev/null 2>&1 ; then
    . /tmp/ipstuff
    for i in $dns ; do
      echo "nameserver $i" >>/etc/resolv.conf
    done
    # simply add a single dns server for passing via kernel cmdline to stage3
    # (quickhack, just the last, list of dns might be better ...)
    echo "dnssrv=$i" >>/tmp/ipstuff
    return
  else
    if [ $i -eq 1 ] ; then
      sleep 1
    else
      echo "Did not get any proper IP configuration"; /bin/ash
    fi
  fi
done
}

#############################################################################
# device files get their own filesystem
devdir="/dev"
mount -n -t tmpfs -o 'size=25%,mode=0755' initramfsdevs ${devdir}
DEBUGLEVEL=0

# create basic device files an directories in dev (for most hardware related
# devices mdev should handle that)
for i in "/dev/mem c 1 1" "/dev/null c 1 3" "/dev/zero c 1 5" \
         "/dev/urandom c 1 9" "/dev/kmsg c 1 11" "/dev/tty0 c 4 0" \
         "/dev/tty1 c 4 1" "/dev/tty2 c 4 2" "/dev/tty3 c 4 3" \
         "/dev/tty4 c 4 4" "/dev/tty5 c 4 5" "/dev/tty6 c 4 6" \
         "/dev/tty7 c 4 7" "/dev/tty8 c 4 8" "/dev/tty9 c 4 9" \
         "/dev/tty10 c 4 10" "/dev/tty c 5 0" "/dev/console c 5 1" \
         "/dev/ptmx c 5 2" "/dev/psaux c 10 1" "/dev/agpgart c 10 175" \
         "/dev/fb0 c 29 0" "/dev/bootsplash p" "/dev/xconsole p"; do
  mknod $i
done
mkdir -p ${devdir}/pts ${devdir}/shm ${devdir}/.udevdb ${devdir}/.udev

# initramfs-setup configuration (common settings for all clients using a
# certain InitRamFS generated by slxmkramfs/mkdxsinitrd)
[ -f /etc/initramfs-setup ] && . /etc/initramfs-setup 2>/dev/null

export PATH=/bin:/sbin:/usr/bin/:/usr/sbin

# set a default LAN interface, has to be modified for WLAN or on machines
# with more than one ethernet card built in
nwif="eth0"

# mount the important standard directories
[ ! -f /proc/cpuinfo ] && mount -n -t proc proc /proc
[ ! -d /sys/class ] && mount -n -t sysfs sysfs /sys

# load network adaptor modules
for mod in ${ramfs_nicmods}; do
  modprobe $mod || echo "module $mod did not load for some reason"
  usleep 10000 
done

# read kernel commandline
read KCMDLINE < /proc/cmdline
# read the system wide machine-setup and then the kernel commandline
for opts in ${KCMDLINE} ; do
  case ${opts} in
    debug)
      DEBUGLEVEL=1;;
    # ... or a specified debug level (will be passed to next stage)
    debug=*)
      DEBUGLEVEL=${opts#debug=};;
  esac
done

# start a watchdog to ensure an automated reboot or halt of the machine if the
# preboot init does not succeed (e.g. missing kernel module/firmware for the
# network adaptor)
if [ "${DEBUGLEVEL}" -gt 0 ] ; then
  cat<<EOF > /bin/watchdog
#!/bin/ash
echo \$$ > /tmp/watchdogpid
[ ! -f /proc/version ] && mount -n -t proc proc /proc
sleep 120 2> /dev/null
echo "o" > /proc/sysrq-trigger
EOF
  chmod u+x /bin/watchdog
  watchdog &
fi

if [ -n "${essid}" ] ; then
  # WLAN setup will most probably change the network interface name stored in
  # nwif (to wlan0 or something like that)
  :
else
  # check here for the active ethernet link
  ip link show dev eth1 >/dev/null 2>&1 && echo "more than one nw if found"
fi

# set up loopback networking and power up ethernet
ip link set dev lo up
ip addr add 127.0.0.1/8 dev lo
ip link set dev $nwif up || echo "I did not find any usable network adaptor."

# run udhcpc and start a debug shell if no lease could be obtained
mkdir -p /usr/share/udhcpc
echo -e "#!/bin/ash\nunset infomsg HOME IFS mask lease interface DEBUGLEVEL \
BOOT_IMAGE\nset >/tmp/ipstuff" >/usr/share/udhcpc/default.script
chmod u+x /usr/share/udhcpc/default.script
modprobe -q af_packet
[ -n $vci ] && vci="-V $vci"
fetchip
ip addr add $ip/$(ipcalc -s -p $ip $subnet|sed s/.*=//) dev $nwif
ip route add default via $router  

# get the mac address of the boot network adaptor
macaddr=$(ip link show dev $nwif 2>/dev/null | \
      sed -n "/ether [0-9e-f]\{2\}:.*/p" | sed -e "s/.*ether //;s/ .*//")
echo "macaddr=$macaddr" >>/etc/initramfs-setup

# at this point a little selection script could be downloaded, which lets the
# user choose what kind of SLX client he wants to get
echo "Fetching preboot interactive part and configuration from the net ..."
wget -q -c -O /tmp/preboot.env $boot_uri/bootloader/${preboot_id}.env
mkdir /preboot
tar -xzf /tmp/preboot.env -C /preboot
# start a debug shell if needed, else set quiet kernel parameter
if [ "${DEBUGLEVEL}" -gt 0 ] ; then
  echo "Starting shell, leaving it would continue init."
  /bin/ash
else
  # no debugging output for stage3 run
  echo "quiet=quiet" >>/etc/initramfs-setup
fi
# run the preboot interactive part which finally will execute kexec
cd /preboot
exec ./preboot.sh
# we should never return from that one ...
echo "The execution of the main preboot environment failed. Please check"
echo "network access of your box. Is $boot_uri reachable!?"
# ping -c 1 $boot_uri
sleep 20 && echo "o" > /proc/sysrq-trigger


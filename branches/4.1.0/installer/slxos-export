#! /usr/bin/perl
# -----------------------------------------------------------------------------
# Copyright (c) 2006, 2007 - OpenSLX GmbH
#
# This program is free software distributed under the GPL version 2.
# See http://openslx.org/COPYING
#
# If you have any feedback please consult http://openslx.org/feedback and
# send your suggestions, praise, or complaints to feedback@openslx.org
#
# General information about OpenSLX can be found at http://openslx.org/
# -----------------------------------------------------------------------------
use strict;

my $abstract = q[
slxos-export
    OpenSLX-script to generate an export from a vendor-OS.
];

use Getopt::Long qw(:config pass_through);
use Pod::Usage;

# add the folder this script lives in and the lib-folder to perl's
# search path for modules:
use FindBin;
use lib "$FindBin::RealBin";
use lib "$FindBin::RealBin/../lib";

use lib "$FindBin::RealBin/../config-db";
	# development path to config-db

use OpenSLX::Basics;
use OpenSLX::OSExport::Engine;

my (
	$helpReq,
	$manReq,
	$verbose,
	$versionReq,
);

GetOptions(
	'help|?' => \$helpReq,
	'man' => \$manReq,
	'verbose' => \$verbose,
	'version' => \$versionReq,
) or pod2usage(2);
pod2usage(-msg => $abstract, -verbose => 0, -exitval => 1) if $helpReq;
if ($manReq) {
	$ENV{LANG} = 'en_EN';
		# avoid dubious problem with perldoc in combination with UTF-8 that
		# leads to strange dashes and single-quotes being used
	pod2usage(-verbose => 2)
}
if ($versionReq) {
	system('slxversion');
	exit 1;
}

openslxInit();

my $action = shift @ARGV;

if ($action =~ m[^list-ex]i) {
	print _tr("List of exported vendor-OSes:\n");
	foreach my $type (sort keys %supportedExportTypes) {
		print join('',	map {
							s[^.+/][];
							"\t$type/$_\n";
						}
						grep {
							# filter out RSYNC_TMP folders:
							$_ !~ m[###];
						}
						sort <$openslxConfig{'export-path'}/$type/*>);
	}
} elsif ($action =~ m[^list-in]i) {
	print _tr("List of installed vendor-OSes:\n");
	print join('', map {
					s[^.+/][];
					"\t$_\n";
				   }
				   sort <$openslxConfig{'stage1-path'}/*>);
} elsif ($action =~ m[^list-ty]i) {
	print _tr("List of supported export types:\n\t");
	print join("\n\t", sort keys %supportedExportTypes)."\n";
} elsif ($action =~ m[^(add|export)]i) {
	if (scalar(@ARGV) != 2) {
		print STDERR _tr("You need to specify exactly one vendor-os-name and one export-type!\n");
		pod2usage(2);
	}
	my $vendorOSName = shift @ARGV;
	my $exportType = shift @ARGV;

	# we chdir into the script's folder such that all relative paths have
	# a known starting point:
	chdir($FindBin::RealBin)
		or die _tr("can't chdir to script-path <%> (%s)", $FindBin::RealBin, $!);

	# create OSExport-engine for given export type and start it:
	my $engine = OpenSLX::OSExport::Engine->new;
	$engine->initializeForNew($vendorOSName, $exportType);
	if (!-e $engine->{'vendor-os-path'}) {
		die _tr("vendor-OS '%s' doesn't exist, giving up!\n",
				$engine->{'vendor-os-path'});
	}
	$engine->exportVendorOS();
} elsif ($action =~ m[^(update)]i) {
	if (scalar(@ARGV) != 1) {
		print STDERR _tr("You need to specify exactly one export-name!\n");
		pod2usage(2);
	}
	my $exportName = shift @ARGV;

	# we chdir into the script's folder such that all relative paths have
	# a known starting point:
	chdir($FindBin::RealBin)
		or die _tr("can't chdir to script-path <%> (%s)", $FindBin::RealBin, $!);

	# create OSExport-engine for given export type and start it:
	my $engine = OpenSLX::OSExport::Engine->new;
	$engine->initializeFromExisting($exportName);
	if (!-e $engine->{'vendor-os-path'}) {
		die _tr("vendor-OS '%s' doesn't exist, giving up!\n",
				$engine->{'vendor-os-path'});
	}
	$engine->updateExportedVendorOS();
} elsif ($action =~ m[^remove]i) {
	if (scalar(@ARGV) != 1) {
		print STDERR _tr("You need to specify exactly one export-name and one export-type!\n");
		pod2usage(2);
	}
	my $exportName = shift @ARGV;

	# we chdir into the script's folder such that all relative paths have
	# a known starting point:
	chdir($FindBin::RealBin)
		or die _tr("can't chdir to script-path <%> (%s)", $FindBin::RealBin, $!);

	# create OSExport-engine for given export type and start it:
	my $engine = OpenSLX::OSExport::Engine->new;
	$engine->initializeFromExisting($exportName);
	$engine->purgeExport();
} else {
	print STDERR _tr("You need to specify exactly one action:
	add
	list-exported
	list-installed
	list-types
	update
	remove
Try '%s --help' for more info.\n", $0);
}



=head1 NAME

slxos-export - OpenSLX-script to generate an export from a vendor-OS.

=head1 SYNOPSIS

slxos-export [options] <action>

=head3 Options

    --help          brief help message
    --man           show full documentation
    --verbose       show more information during execution
    --version       show version

=head3 Actions

=over 8

=item B<<     add <vendor-OS-name> <export-type> >>

exports the vendor-OS with the given name using the given export type and
adds it to the config-DB, too. The export will be named as the vendor-OS,
but with an additional '-<X>' appended to it (where <X> will be replaced
by the letter A,B,C ...).

=item B<<     list-exported >>

list all exported vendor-OSes

=item B<<     list-installed >>

list all installed vendor-OSes

=item B<<     list-types >>

list all supported export types

=item B<<     update <export-name> >>

updates the export with the given name, i.e. the contents of the vendor-OS
is synced to the export

=item B<<     remove <export-name> >>

removes the export with the given name from disk and config-DB

=back

=head1 DESCRIPTION

B<slxos-export> converts an installed vendor-OS into a form that can be accessed
via network by booting clients.

The resulting form of such a conversion is called an I<export> and those come
in different flavors:

=over 8

=item B<    Export Type 'NFS'>

NFS (network file system) is a well established networking file system, which
is supported by LINUX since long.

=item B<    Export Type 'NBD-squash'>

A rather modern concept is the network block device, which basically "transports"
a block device over the network (from server to client), making it possible to
use more or less any file system over the network. In this particular case,
a squash-FS is being used, which is a filesystem providing very good compression,
resulting in considerably reduced network traffic during boot (and execution).

=back

When invoking slxos-export, you have to pass it a vendor-OS name and the export
type you want to use and it will do the conversion (which can take a while, so
please be patient).

The resulting export will be stored under C</srv/openslx/export>.

=head1 OPTIONS

=over 4

=item B<--help>

Prints a brief help message and exits.

=item B<--man>

Prints the manual page and exits.

=item B<--verbose>

Prints more information during execution of any action.

=item B<--version>

Prints the version and exits.

=back

=head1 EXAMPLES

=over 8

=head3 Exporting a Vendor-OS via NFS

=item B<<     slxos-export export suse-10.2 nfs >>

Exports the installed vendor-OS suse-10.2 via nfs, the
resulting NFS-export will live in C</srv/openslx/export/nfs/suse-10.2>.

=back

=head3 Exporting a Vendor-OS via NBD-Squash

=over 8

=item B<<     slxos-export export ubuntu-6.10 nbd-squash >>

Exports the installed vendor-OS ubuntu-6.10 via nbd-squash, the resulting
Squash-FS will live in C</srv/openslx/export/nbd-squash/ubuntu-6.10>.

=back

=head3 Removing an Export

=over 8

=item B<<     slxos-export remove ubuntu-6.10 nbd-squash >>

Wipes the squash-FS of the export named 'ubuntu-6.10' from disk (i.e. the
file C</srv/openslx/export/nbd-squash/ubuntu-6.10> will be deleted) and
removes that export from the config-DB, too.

=back

=head1 SEE ALSO

slxsettings, slxos-setup, slxconfig, slxconfig-demuxer

=head1 GENERAL OPENSLX OPTIONS

Being a part of OpenSLX, this script supports several other options
which can be used to overrule the OpenSLX settings:

    --base-path=<string>       basic path to project files
    --bin-path=<string>        path to binaries and scripts
    --config-path=<string>     path to configuration files
    --db-basepath=<string>     basic path to openslx database
    --db-datadir=<string>      data folder created under db-basepath
    --db-name=<string>         name of database
    --db-spec=<string>         full DBI-specification of database
    --db-type=<string>         type of database to connect to
    --export-path=<string>     path to root of all exported filesystems
    --locale=<string>          locale to use for translations
    --logfile=<string>         file to write logging output to
    --private-path=<string>    path to private data
    --public-path=<string>     path to public (client-accesible) data
    --share-path=<string>      path to sharable data
    --stage1-path=<string>     path to stage1 systems
    --temp-path=<string>       path to temporary data
    --tftpboot-path=<string>   path to root of tftp-server
    --verbose-level=<int>      level of logging verbosity (0-3)

Please refer to the C<slxsettings>-manpage for a more detailed description
of these options.

=cut